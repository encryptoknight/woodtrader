// Generated by CoffeeScript 1.4.0

/*
This entity calls the triggeredBy( entity, trigger ) method of each of its
targets. #entity# is the entity that triggered this trigger and #trigger#
is the trigger entity itself.


Keys for Weltmeister:

checks
	Specifies which type of entity can trigger this trigger. A, B or BOTH
	Default: A

wait
	Time in seconds before this trigger can be triggered again. Set to -1
	to specify "never" - e.g. the trigger can only be triggered once.
	Default: -1

target.1, target.2 ... target.n
	Names of the entities whose triggeredBy() method will be called.
*/


(function() {
  /*;

  var EntityTrigger;

  EntityTrigger = {};

  */;


  ig.module('game.entities.common.trigger').requires('impact.entity').defines(function() {
    return EntityTrigger = ig.Entity.extend({
      size: {
        x: 16,
        y: 16
      },
      _wmScalable: true,
      _wmDrawBox: true,
      _wmBoxColor: 'rgba(196, 255, 0, 0.7)',
      target: null,
      wait: -1,
      waitTimer: null,
      canFire: true,
      type: ig.Entity.TYPE.NONE,
      checkAgainst: ig.Entity.TYPE.A,
      collides: ig.Entity.COLLIDES.NEVER,
      init: function(x, y, settings) {
        if (settings.checks) {
          this.checkAgainst = ig.Entity.TYPE[settings.checks.toUpperCase()] || ig.Entity.TYPE.A;
          delete settings.check;
        }
        this.parent(x, y, settings);
        return this.waitTimer = new ig.Timer();
      },
      check: function(other, functionName) {
        var ent, index, target, _ref;
        if (functionName == null) {
          functionName = 'triggeredBy';
        }
        if (functionName !== 'triggeredBy') {
          functionName += 'Trigger';
        }
        if (this.canFire && this.waitTimer.delta() >= 0) {
          if (typeof this.target === 'object') {
            _ref = this.target;
            for (index in _ref) {
              target = _ref[index];
              ent = ig.game.getEntityByName(target);
              if (ent && typeof ent[functionName] === 'function') {
                ent[functionName](other, this);
              }
            }
          }
          if (this.wait === -1) {
            return this.canFire = false;
          } else {
            return this.waitTimer.set(this.wait);
          }
        }
      },
      update: function() {}
    });
  });

}).call(this);
